// for the react-native cli 
import { useChunkStore } from "@/db/chunkStore";
import { createContext, FC, useCallback, useContext, useState } from "react";
import TCpSocket from 'react-native-tcp-socket';
import Device from "expo-device";
import { Alert, Platform } from 'react-native';
import * as FileSystem from 'expo-file-system';
import { v4 as uuidv4 } from 'uuid';
import { produce } from 'immer';
import { Buffer } from "buffer";
import { receiveFileAck, sendChunkAck, receiveChunk } from "./TCPUtills";

interface TCPContextType {
    server: any;
    client: any;
    isConnected: boolean;
    connectedDevices: any[];
    sentFiles: any[];
    receivedFiles: any[];
    totalSentBytes: number;
    totalReceivedBytes: number;
    startServer: (port: number) => void;
    connectToServer: (host: string, port: number, deviceName: string) => void;
    sendMessage: (message: string | Buffer) => void;
    sendFileAck: (file: any, type: 'file' | 'image') => void;
    disconnect: () => void;
}

const TCPContext = createContext<TCPContextType | undefined>(undefined)

export const useTCP = (): TCPContextType => {
    const context = useContext(TCPContext);
    if (!context) {
        throw new Error('useTCP must be used within a TCProvider')
    }
    return context
}
const options = {
    keystore: require('../tls_certs/server-keystore.p12'),
}

export const TCPProvider: FC<{ children: React.ReactNode }> = ({ children }) => {
    const [server, setServer] = useState<any>(null);
    const [client, setClient] = useState<any>(null);
    const [isConnected, setIsConnected] = useState(false);
    const [connectedDevices, setConnectedDevices] = useState<any[]>([]);
    const [serverSocket, setServerSocket] = useState<any>(null);
    const [sentFiles, setSentFiles] = useState<any[]>([]);
    const [receivedFiles, setReceivedFiles] = useState<any[]>([]);
    const [totalSentBytes, setTotalSentBytes] = useState<number>(0);
    const [totalReceivedBytes, setTotalReceivedBytes] = useState<number>(0);

    const { setCurrentChunkSet, setChunkStore } = useChunkStore();

    // DISCONNECT

    const disconnect = useCallback(() => {
        if (client) {
            client.destroy();
        }
        if (server) {
            server.close();
        }
        setReceivedFiles([]);
        setSentFiles([]);
        setCurrentChunkSet(null);
        setTotalReceivedBytes(0);
        setChunkStore(null);
        setIsConnected(false);
    }, [client, server]);


    // START SERVER
    const startServer = useCallback((port: number) => {
        if (server) {
            console.log('Server already running');
            return;
        }
        const newServer = TCpSocket.createTLSServer(options, (socket) => {
            console.log('client connected:', socket.address());
            socket.setNoDelay(true);
            socket.readableHighWaterMark = 1024 * 1024 * 1;
            socket.writableHighWaterMark = 1024 * 1024 * 1;

            socket.on('data', async (data) => {
                const parsedData = JSON.parse(data.toString());
                if (parsedData?.event === 'connect') {
                    setIsConnected(true);
                    setConnectedDevices((prev: any[]) => [...prev, parsedData?.deviceName]);
                }

                if (parsedData?.event === 'file-ack') {
                    receiveFileAck(parsedData?.file, socket, setReceivedFiles);
                }
                if (parsedData.event === 'send_chunk_ack') {
                    sendChunkAck(parsedData?.chunkNo, socket, setTotalSentBytes, setSentFiles);
                }
                if (parsedData.event === 'receive_chunk_ack') {
                    receiveChunk(parsedData?.chunk, parsedData?.chunkNo, socket, setTotalReceivedBytes, generateFile);
                }
            });


            socket.on('close', () => {
                console.log('client disconnected');
                setReceivedFiles([]);
                setSentFiles([]);
                setCurrentChunkSet(null);
                setTotalReceivedBytes(0);
                setChunkStore(null);
                setIsConnected(false);
                disconnect();
            });

            socket.on('error', (error) => {
                console.log('Socket error:', error);
            });
        });

        newServer.listen({ port, host: '0.0.0.0' }, () => {
            const address = newServer.address();
            console.log(`server running on ${address?.address}:${address?.port}`)
        });

        newServer.on('error', (error) => {
            console.log('Server error:', error);
        });

        setServerSocket(newServer);
        setServer(newServer);
    }, [server]);

    // START CLIENT CONNECTION

    const connectToServer = useCallback((host: string, port: number, deviceName: string) => {
        const newClient = TCpSocket.connectTLS(
            {
                host,
                port,
                cert: true,
                ca: require('../tls_certs/server-cert.pem'),
            },
            async () => {
                setIsConnected(true);
                setConnectedDevices((prev: any[]) => [...prev, deviceName]);
                const myDeviceName = await Device.getDeviceTypeAsync();
                newClient.write(
                    JSON.stringify({ event: 'connect', deviceName: myDeviceName }),
                );
            },
        );
        newClient.setNoDelay(true);
        newClient.readableHighWaterMark = 1024 * 1024 * 1;
        newClient.writableHighWaterMark = 1024 * 1024 * 1;

        newClient.on('data', async (data) => {
            const parsedData = JSON.parse(data.toString());
            if (parsedData?.event === 'file-ack') {
                receiveFileAck(parsedData?.file, newClient, setReceivedFiles);
            }
            if (parsedData.event === 'send_chunk_ack') {
                sendChunkAck(parsedData?.chunkNo, newClient, setTotalSentBytes, setSentFiles);
            }
            if (parsedData.event === 'receive_chunk_ack') {
                receiveChunk(parsedData?.chunk, parsedData?.chunkNo, newClient, setTotalReceivedBytes, generateFile);
            }
        });

        newClient.on('close', () => {
            console.log('connection closed');
            setReceivedFiles([]);
            setSentFiles([]);
            setCurrentChunkSet(null);
            setTotalReceivedBytes(0);
            setChunkStore(null);
            setIsConnected(false);
            disconnect();
        });

        newClient.on('error', (error) => {
            console.log('Client error:', error);
        });

        setClient(newClient);
    },
        [],
    );

    // GENERATE FILE FROM CHUNKS

    const generateFile = async () => {
        const { chunkStore, resetChunkStore } = useChunkStore.getState();
        if (!chunkStore) {
            console.log('No chunk store available');
            return;
        }
        if (chunkStore?.totalchunks !== chunkStore.checkArray.length) {
            console.log('Not all chunks received yet');
            return;
        }

        try {
            // Ensure checkArray is an array of Uint8Array or Buffer
            const combinedChunks = Buffer.concat(chunkStore.checkArray as Buffer[]);
            const platformPath = Platform.OS === 'android'
                ? FileSystem.documentDirectory
                : FileSystem.documentDirectory;

            const fileUri = `${platformPath}${chunkStore.name}`;
            // Write the combinedChunks to the file using Expo FileSystem's writeAsStringAsync with base64 encoding
            await FileSystem.writeAsStringAsync(
                fileUri,
                combinedChunks?.toString('base64'),
                { encoding: FileSystem.Encoding.Base64 }
            );
            setReceivedFiles(prevFiles =>
                produce(prevFiles, (draftFiles: any) => {
                    const fileIndex = draftFiles.findIndex((f: any) => f.id === chunkStore.id);
                    if (fileIndex !== -1) {
                        draftFiles[fileIndex] = {
                            ...draftFiles[fileIndex],
                            uri: fileUri,
                            available: true,
                        };
                    }
                })
            );
            console.log(`File saved to ${fileUri}`, resetChunkStore());
        }
        catch (error) {
            console.error('Error generating file from chunks:', error);
        }
    };

    // SEND MESSAGE
    const sendMessage = useCallback((message: string | Buffer) => {
        if (client) {
            client.write(JSON.stringify(message));
            console.log('sent from client:', message);
        }
        else if (server) {
            serverSocket?.write(JSON.stringify(message));
            console.log('sent from server:', message);
        }
        else {
            console.log('No client or server connected');
        }
    }, [client, server, serverSocket]);

    // SEND FILE ACK

    const sendFileAck = async (file: any, type: 'file' | 'image') => {
        // Remove currentClient check, as it is not defined
        // Alert if a transfer is already in progress can be handled differently if needed

        const path = Platform.OS === 'android'
            ? file?.url?.replace('file://', '')
            : file?.uri;

        // Use the correct encoding property
        const fileData = await FileSystem.readAsStringAsync(path, { encoding: FileSystem.Encoding.Base64 });
        const CHUNK_SIZE = 1024 * 8; // 8KB

        let totalchunks = 0;
        let offset = 0;
        // Use Buffer[] for chunkArray
        let chunkArray: Buffer[] = [];

        const fileBuffer = Buffer.from(fileData, 'base64');

        while (offset < fileBuffer.length) {
            const chunk = fileBuffer.slice(offset, offset + CHUNK_SIZE);
            totalchunks += 1;
            chunkArray.push(chunk);
            offset += chunk.length;
        }

        const rawData = {
            id: uuidv4(),
            name: type === 'file' ? file?.name : file?.fileName,
            size: type === 'file' ? file?.size : file?.fileSize,
            mineType: type === 'file' ? 'file' : '.jpg',
            totalchunks,
        };

        setCurrentChunkSet({
            id: rawData?.id,
            chunkArray,
            totalchunks
        });

        setSentFiles(prevData =>
            produce(prevData, (draft: any) => {
                draft.push({
                    ...rawData,
                    uri: file?.uri,
                });
            })
        );

        const socket = client || serverSocket;
        if (!socket) return;

        try {
            console.log('file ack done');
            socket.write(
                JSON.stringify({ event: 'file-ack', file: rawData }),
            );
        } catch (error) {
            console.log('Error sending file ack:', error);
        }
    };
    return (
        <TCPContext.Provider value={{
            server,
            client,
            connectedDevices,
            sentFiles,
            receivedFiles,
            isConnected,
            totalSentBytes,
            totalReceivedBytes,
            startServer,
            connectToServer,
            sendMessage,
            disconnect,
            sendFileAck
        }}>
            {children}
        </TCPContext.Provider>
    );
};